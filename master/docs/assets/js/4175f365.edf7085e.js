"use strict";(self.webpackChunkdocusaurus=self.webpackChunkdocusaurus||[]).push([[7620],{1898:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var s=n(4848),o=n(8453);const r={sidebar_position:5},a="High-level overview of how Plutus Tx works",i={id:"using-plutus-tx/overview-plutus-tx",title:"High-level overview of how Plutus Tx works",description:"Plutus Tx is a high-level language for writing the validation logic of the contract, the logic that determines whether a transaction is allowed to spend a UTXO.",source:"@site/docs/using-plutus-tx/overview-plutus-tx.md",sourceDirName:"using-plutus-tx",slug:"/using-plutus-tx/overview-plutus-tx",permalink:"/plutus/master/docs/using-plutus-tx/overview-plutus-tx",draft:!1,unlisted:!1,editUrl:"https://github.com/IntersectMBO/plutus/edit/master/docusaurus/docs/using-plutus-tx/overview-plutus-tx.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Using Plutus Tx",permalink:"/plutus/master/docs/category/using-plutus-tx"},next:{title:"Writing Plutus Tx programs",permalink:"/plutus/master/docs/using-plutus-tx/writing-plutus-tx-programs"}},u={},l=[{value:"Staged metaprogramming",id:"staged-metaprogramming",level:2}];function c(e){const t={code:"code",em:"em",h1:"h1",h2:"h2",p:"p",...(0,o.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.h1,{id:"high-level-overview-of-how-plutus-tx-works",children:"High-level overview of how Plutus Tx works"}),"\n",(0,s.jsx)(t.p,{children:"Plutus Tx is a high-level language for writing the validation logic of the contract, the logic that determines whether a transaction is allowed to spend a UTXO.\nPlutus Tx is not a new language, but rather a subset of Haskell, and it is compiled into Plutus Core, a low-level language based on higher-order polymorphic lambda calculus.\nPlutus Core is the code that runs on-chain, i.e., by every node validating the transaction, using an interpreter known as the CEK machine.\nA Plutus Core program included in a Cardano transaction is often referred to as a Plutus script or a Plutus validator."}),"\n",(0,s.jsx)(t.p,{children:"To develop and deploy a smart contract, you also need off-chain code for building transactions, submitting transactions, deploying smart contracts, querying for available UTXOs on the chain, and so on.\nYou may also want a front-end interface for your smart contract for better user experiences."}),"\n",(0,s.jsxs)(t.p,{children:["A Plutus application, or ",(0,s.jsx)(t.code,{children:"Plutus Tx"})," program, where 'Tx' indicates that the component usually goes into a transaction, is written as a single Haskell program.\nThe Plutus Tx program describes both the code that runs off the chain (for example, on a user's computer, or in their wallet), and on the chain as part of transaction validation.\nThe parts of the program that describe the on-chain code are compiled into ",(0,s.jsx)(t.code,{children:"Plutus Core"}),"."]}),"\n",(0,s.jsx)(t.h2,{id:"staged-metaprogramming",children:"Staged metaprogramming"}),"\n",(0,s.jsxs)(t.p,{children:["The key technique used to implement Plutus Tx is called ",(0,s.jsx)(t.em,{children:"staged metaprogramming"}),", which means that the main Haskell program generates ",(0,s.jsx)(t.em,{children:"another"})," program (in this case, the Plutus Core program that will run on the blockchain).\nPlutus Tx is the mechanism used to write those programs, but since Plutus Tx is just part of the main Haskell program, we can share types and definitions between the two."]})]})}function h(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var s=n(6540);const o={},r=s.createContext(o);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);